
## Dart 컴파일러의 디버그 모드, 릴리즈 모드 나눠서 각각 컴파일 방식에 대해서 설명해주세요.
## Dart 스타일 가이드 권장 방식 기준으로 언제 var를 쓰고, 언제 타입을 명시할까요? 그리고 어떤 이유로 변수 타입을 명시하지 않아도 되는 걸까요?
## Dynamic 타입이 왜 필요할까?
## dart에서 변수는 기본적으로 nullable (null 값이 될 수 있다)한가요? non-nullable 한가요?  그리고 null safety란 무엇인가요?
## dart에서 const의 의미는? const, final 차이점은?

## late를 언제, 왜 쓰나
## list, map, set, collection for, collection if 각각 언제 쓰는 게 좋을까?
## Mixins이 뭔가요? 언제,왜 쓰나요? extend와 비교해서 차이점은? 그리고 Mixins의 조건은?

--- 
# Dart 컴파일러의 디버그 모드, 릴리즈 모드 나눠서 각각 컴파일 방식에 대해서 설명해주세요.
- 릴리즈 모드 - AOT 컴파일러(배포용: 사용자에게 초점)
    - 다트 소스코드(애플리케이션+dart SDK)를 기계언어(ARM)으로 컴파일한다.
    - AHEAD OF TIME -> 사용자에게 프로덕트를 내보이기 전에 미리 컴파일 해서 준비해둔다는 뜻.
    - pre-최적화로 일관된 성능 제공
- 디버그 모드 - JIT 컴파일러(개발용)
    - JUST IN TIME
    - 실행 중에 코드를 즉시 최적화한다. (런타임에서 최적화 기능)
    - Dart JIT 컴파일러는 인터프리터를 함께 사용한다. 그래서 핫리로드 기능이 지원 가능하다.
        - 인터프리터: 코드를 한 줄 씩 입력 받아서 번역과 동시에 코드를 실행한 후 그 결과를 출력하는 방식 (컴파일보다 느리다, 파이썬, 자바스크립트)

# Dart 스타일 가이드 권장 방식 기준으로 언제 var를 쓰고, 언제 타입을 명시할까요? 그리고 어떤 이유로 변수 타입을 명시하지 않아도 되는 걸까요?
- 함수 안에서 지역 변수를 선언하거나, 메서드 안에서 지역 변수를 선언하는 상황이라면 var 사용
    - 왜? 컴파일러가 어차피 타입을 추론할 수 있기 때문
- class의 property를 작성할 때는 타입 명시해서 작성하는 걸 권장한다.

Dynamic 타입이 왜 필요할까?
- 변수가 어떤 타입인지 알기 어려운 경우가 있다.
    - fluuter, json
- 가끔 dynamic으로 돌아가는 게 유용한 경우도 있다.
    - API에서 데이터를 받았을 때 데이터 타입을 모르는 경우 dynamic을 이용해서 dart가 데이터 타입을 확인할 수 있게 도와준다.
- 하지만 쓰지 않는 게 좋고, 정말로 필요할 때만 써야함.


# dart에서 변수는 기본적으로 nullable (null 값이 될 수 있다)한가요? non-nullable 한가요?  그리고 null safety란 무엇인가요?
- non-nullable
- null safety
    - 어떤 변수 혹은 데이터가 null이 될 수 있음을 명시하는 것 -> 개발자가 null값을 참조할 수 없게 하는 것
    - null safety는 nullable 변수를 선언하는 것과 같다.

# dart에서 const의 의미는? const, final 차이점은?
- compile-time constant
- 반드시 컴파일 타임 때 알고 있는 값이어야 한다.
    - api에서 받아온 값을 const 변수에 쓸 수 없음.
        - final(재할당 불가)이나 var를 써야함

# late를 언제, 왜 쓰나
- 변수를 사용하기 전에 먼저 데이터를 넣었는지 확인해준다. -> 아직 정의되지 않은 late 변수에 접근할 수 없음(컴파일 에러 발생)
- 정의해주고 싶은 뭔가가 있는데 API로 값을 받아와야 알 수 있을 때 쓴다.
    - 변수는 먼저 만들어놓고 데이터를 받아와서 그 뒤에 그 변수를 사용하겠다는 의미

# list, map, set, collection for, collection if 각각 언제 쓰는 게 좋을까?
- Dart에서 `list`, `map`, `set`은 각기 다른 데이터 구조를 나타낸다. 
- 그리고 `collection for`와 `collection if`는 컬렉션을 생성하기 위한 편리한 방법을 제공한다.

1. **List**:
    - 순서가 있는 요소들의 모음을 저장할 때 사용
    - 인덱스를 통해 요소에 접근할 수 있다
    - 예를 들어, 리스트에서 요소를 추가, 제거, 변경하는 작업이 필요할 때 사용

2. **Map**:
    - Key-Value 쌍을 저장할 때 사용
    - 각 요소는 고유한 키에 의해 식별된다
    - 주로 데이터를 검색하고 조작할 때 사용한다

3. **Set**:
    - 고유한 요소들의 집합을 나타낸다
    - 순서가 없고, 중복된 요소를 허용하지 않는다
    - 주로 집합 연산이 필요할 때 사용한다

4. **Collection for**:
    - 컬렉션을 생성할 때 사용
    - 기존의 리스트나 맵 등의 컬렉션에서 새로운 컬렉션을 생성할 때 편리하다
    - 리스트나 맵의 각 요소를 변환하거나 필터링할 때 사용한다

5. **Collection if**:
    - 컬렉션을 생성하는 동안 조건을 확인하고 조건이 참일 때만 해당 요소를 포함한다
    - 컬렉션의 생성을 조건에 따라 조절할 수 있다
    - 예를 들어, 특정 조건을 만족하는 요소만을 포함하는 리스트를 생성할 때 사용한다


# Mixins이 뭔가요? 언제,왜 쓰나요? extend와 비교해서 차이점은? 그리고 Mixins의 조건은?
- with 키워드
- with로 연결된 클래스의 프로퍼티, 메서드들을 쓸 수 있게 된다.
- 재사용 목적
- Mixins의 조건은?
    - 생성자가 없는 클래스여야 한다. 
